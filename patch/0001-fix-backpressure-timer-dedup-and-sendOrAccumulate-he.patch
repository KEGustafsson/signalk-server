From 0974ec74519cbeeda5bb1f9e6d18d99ef91a559f Mon Sep 17 00:00:00 2001
From: Claude <noreply@anthropic.com>
Date: Sun, 22 Feb 2026 14:00:00 +0000
Subject: [PATCH 1/4] fix: backpressure timer dedup and sendOrAccumulate helper

Two independent backpressure bugs:

1. Each $backpressure server event in actions.js queued a fresh 10-second
   setTimeout for BACKPRESSURE_WARNING_CLEAR without cancelling the
   previous one. Under sustained congestion the timers accumulated,
   firing redundant state updates long after the warning was cleared.
   Track the single active timer and cancel it before rescheduling.

2. The backpressure enter/accumulate block was duplicated verbatim in
   both the onChange realtime handler and the processSubscribe callback
   in ws.js. Extract it into sendOrAccumulate() to remove the duplication.

https://claude.ai/code/session_0142hccyF52oZwDAmLrntwTp
---
 packages/server-admin-ui/src/actions.js | 12 ++++-
 src/interfaces/ws.js                    | 67 ++++++++++---------------
 2 files changed, 37 insertions(+), 42 deletions(-)

diff --git a/packages/server-admin-ui/src/actions.js b/packages/server-admin-ui/src/actions.js
index 586cc78..b82bea7 100644
--- a/packages/server-admin-ui/src/actions.js
+++ b/packages/server-admin-ui/src/actions.js
@@ -156,6 +156,10 @@ export function fetchAllData(dispatch) {
   fetchAccessRequests(dispatch)
 }
 
+// Single timer shared across connections so stale auto-clear dispatches
+// from a previous burst of backpressure events cannot race with newer ones.
+let backpressureClearTimer = null
+
 export function openServerEventsConnection(dispatch, isReconnect) {
   const proto = window.location.protocol === 'https:' ? 'wss' : 'ws'
   const ws = new WebSocket(
@@ -178,8 +182,12 @@ export function openServerEventsConnection(dispatch, isReconnect) {
           timestamp: Date.now()
         }
       })
-      // Auto-clear after 10 seconds
-      setTimeout(() => {
+      // Cancel any pending clear so only the most recent event's timer fires
+      if (backpressureClearTimer) {
+        clearTimeout(backpressureClearTimer)
+      }
+      backpressureClearTimer = setTimeout(() => {
+        backpressureClearTimer = null
         dispatch({ type: 'BACKPRESSURE_WARNING_CLEAR' })
       }, 10000)
     }
diff --git a/src/interfaces/ws.js b/src/interfaces/ws.js
index 47992cc..d429965 100644
--- a/src/interfaces/ws.js
+++ b/src/interfaces/ws.js
@@ -224,26 +224,7 @@ module.exports = function (app) {
           )
           if (!filtered) return
 
-          const bufferSize = spark.request.socket.bufferSize
-
-          if (bufferSize > BACKPRESSURE_ENTER_THRESHOLD) {
-            // Enter/stay in backpressure mode - accumulate latest values only
-            if (!spark.backpressure.active) {
-              spark.backpressure.active = true
-              spark.backpressure.since = Date.now()
-              debug(
-                'Entering backpressure mode for spark %s (buffer: %d)',
-                spark.id,
-                bufferSize
-              )
-            }
-            accumulateLatestValue(spark.backpressure.accumulator, filtered)
-          } else {
-            // Normal mode - send immediately
-            sendMetaData(app, spark, filtered)
-            spark.write(filtered)
-          }
-
+          sendOrAccumulate(app, spark, filtered)
           assertBufferSize(spark)
         }
 
@@ -695,26 +676,7 @@ function processSubscribe(app, unsubscribes, spark, assertBufferSize, msg) {
         )
         if (!filtered) return
 
-        const bufferSize = spark.request.socket.bufferSize
-
-        if (bufferSize > BACKPRESSURE_ENTER_THRESHOLD) {
-          // Enter/stay in backpressure mode - accumulate latest values only
-          if (!spark.backpressure.active) {
-            spark.backpressure.active = true
-            spark.backpressure.since = Date.now()
-            debug(
-              'Entering backpressure mode for spark %s (buffer: %d)',
-              spark.id,
-              bufferSize
-            )
-          }
-          accumulateLatestValue(spark.backpressure.accumulator, filtered)
-        } else {
-          // Normal mode - send immediately
-          sendMetaData(app, spark, filtered)
-          spark.write(filtered)
-        }
-
+        sendOrAccumulate(app, spark, filtered)
         assertBufferSize(spark)
       },
       spark.request.skPrincipal
@@ -851,6 +813,31 @@ function sendLatestDeltas(app, deltaCache, selfContext, spark) {
     })
 }
 
+/**
+ * Send a filtered delta to the client, applying backpressure if the socket
+ * buffer is over threshold.  Extracted to avoid duplicating this logic in
+ * both the realtime onChange handler and the subscription callback.
+ */
+function sendOrAccumulate(app, spark, filtered) {
+  const bufferSize = spark.request.socket.bufferSize
+
+  if (bufferSize > BACKPRESSURE_ENTER_THRESHOLD) {
+    if (!spark.backpressure.active) {
+      spark.backpressure.active = true
+      spark.backpressure.since = Date.now()
+      debug(
+        'Entering backpressure mode for spark %s (buffer: %d)',
+        spark.id,
+        bufferSize
+      )
+    }
+    accumulateLatestValue(spark.backpressure.accumulator, filtered)
+  } else {
+    sendMetaData(app, spark, filtered)
+    spark.write(filtered)
+  }
+}
+
 function startServerLog(app, spark) {
   const onServerLogEvent = wrapWithverifyWS(
     app.securityStrategy,
-- 
2.43.0

